在制造硅芯片时,材料(例如，硅)的缺陷和制造错误会导致电路失效。一个非常普遍的问题是
一根线上的信号会对相邻线上的信号产生影响，这被称为串扰。有- -类串扰问题是这样的，某些
线上的信号为常值( 如电源线)，该线附近的线也被固定为0 (stuck-at-0) 或1 ( stuck-at-1)。下
面的问题中的缺陷发生在图4-24中寄存器堆的写寄存器输人端的第0位。
4.6.1 [10]<4.3.4.4>假设这样测试处理器的缺陷:先给PC、寄存器堆、数据和指令存储器中设置
-些值(可以自己选择)，执行-条指令，然后读出PC、寄存器堆和存储器中的值;最后检查这
些值以判断处理器中是否存在缺陷。你能设计一个方案检查该信号上是否有固定为0缺陷吗?
4.6.2 [10]<4.3. 4.4>重做练习题4.6.1.这次检查固定为1缺陷。你能只设计- -个测试方案同时检
查固定为0缺陷和固定为1缺陷吗?如果可以，请解释如何实现;如果不能，请说明理由。
4.6.3 [60]<4.3. 4.4>如果我们知道一个处理器在该信号上有一个固定为1缺陷，它还能用吗?为了
使这个处理器仍然可用，我们必领将原来能在正常MIPS处理器上运行的程序作一些变换，使之
可以在这个处理器上运行。假设指令存储器和数据存储器都很大，足够容纳变换后的程序。提
示:将因为该缺陷不能用的指令替换为一系列能用的指令，这一系列指令与原指令功能相同。
4.6.4 [10]<4.3.4.4>重做练习题4.6.1,这次检测控制信号MemRead是否存在该缺陷?如果
RegDst控制信号为0时，MemRead控制信号为0，则有缺陷，否则无缺陷。
4.6.5 [10] <4.3. 4.4>重做练习题4.6.4，这次检测控制信号Jump是否存在该缺陷?如果RegDst控
制信号为0时Jump控制信号为0.则有缺陷，否则无缺陷。


答:
4.6.1
要测试一条线上的stuck-at-0错误，我们需要用一条往线路传输1的指令，如果真的存在错误会出现不符合预期的结果。
如果一个信号固定为0，一个向奇数寄存器的写，会被错误的写到一个偶数寄存器，所以如果
我们将R30置为0，并且将R31置为1，然后执行 ADD R31, R30,R30 理论上R31中的值应该为0
但是如果第零位的bit如果固定为0的话，向R31写入的值，实际上会被写入R30中，而R31中的值
保持为1

4.6.2
测试stuck-at-0错误我们需要一条设置1信号的指令，要测试stuck-at-1错误我们需要一条设置
0信号的指令，因为信号不可能即为0又为1所以我们不能同时进行stuck-at-0和stuck-at-1测试
。测试stuck-at-1错误和测试stuck-at-0错误类似:
我们可以向R31置为0，向R30置为1，然后执行ADD R30, R31, R31如果存在stuck-at-1错误
那么结果值会被写入R31，并且R30的值保持为1

4.6.3 
需要将程序重写为，只使用奇数寄存器

4.6.4
为了测试这个故障，我们需要一条MemRead为1的指令，所以它必须是一条加载指令。
这条指令还需要将RegDst设置为0，这也是加载的情况。最后，如果MemRead被设置为0，
指令需要有不同的结果。对于加载来说，MemRead=0的结果是不读取内存，
所以放在寄存器中的值是 "随机 "的（无论内存单元的输出是什么）。
不幸的是，这个 "随机 "值可能与已经在寄存器中的值相同，所以这个测试并不是决定性的。

4.6.5
为了测试这个故障，我们需要一条Jump为1的指令，所以它必须是跳转指令。
然而，对于跳转指令来说，RegDst信号是不被在意的，因为它不写任何寄存器，
所以实现可能允许也可能不允许我们将RegDst设置为0，以便我们可以测试这个故障。
因此，我们不能可靠地测试这个故障。
