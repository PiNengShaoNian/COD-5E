4.17本练习题讨论异常处理对流水线设计的影响。根据下面两条指令回答前三个问题:
指令1                       指令2
BNE R1, R2, Label        LW R1, 0(R1)
4.17.1 [5]<4. 9>每条指令分别可能产生什么异常?对每个可能产生的异常，指出其将在哪个流水线
级被检测到。
4.17.2 [10] <4.9>如果每个异常都有独立的处理程序地址，流水线应该怎样设计才能处理异常?假设
设计处理器时已知每个异常处理程序的地址。
4.17.3 [10] <4.9>如果第二条指令紧跟第一条指令从表中取出，试说明第一条指令发生异常(见练
习题4.17.1)时流水线的运行情况。给出从第一条指令取指开始到异常处理程序第一条指令完
成时的流水线运行图。
4.17.4 [20] <4.9>在向量异常处理中，异常处理程序地址表在数据存储器的一个固定位置。改变流水
线的实现以支持向量异常处理。重做练习题4. 17.3,这次使用支持向量异常处理的流水线。
4.17.5[15]<4.9>我们想要在仅有一个固定处理程序地址的处理器上模拟向量异常处理(见练习题
4.17.4)，写出相应的程序。提示:这段程序应识别异常类型，从异常向量表中获得正确地址，
然后跳转到该异常处理程序处。

答:
4.17.1
instruction1                       instruction2
Invalid target address(EX)      Invalid data address(MEM)

4.17.2
选择下一台PC的Mux必须有输入。每个输入是一个异常处理程序的恒定地址。异常检测器必须被添加到适当的流水线阶段，
这些检测器的输出必须被用来控制前PC Mux，也可以将已经在异常触发指令后面的流水线中的指令转换为NOP。

4.17.3
在检测到异常之前，指令是正常获取的。当检测到异常时，所有在第一条指令之后的流水线上的指令必须被转换为NOP。
因此，第二条指令永远不会完成，也不会影响流水线的状态。在紧接着检测到异常的周期中，处理器将获取异常处理程序的第一条指令。

4.17.4
这种方法要求我们从内存中获取处理程序的地址。我们必须将异常的代码添加到异常向量表的地址中，
从内存中读取处理程序的地址，然后跳转到该地址。一种方法是把它当作一条特殊指令来处理，
在EX中计算地址，在MEM中加载处理程序的地址，并在WB中设置PC。

4.17.5
我们需要一条特殊的指令，允许我们将一个值从（异常）原因寄存器移到一个通用寄存器中。
我们必须首先保存通用寄存器（这样我们以后可以恢复它），将Cause寄存器加载到其中，
将向量表的地址加到其中，将结果作为加载的地址，从内存中获取正确的异常处理程序的地址，最后跳转到该处理程序。
